package fantasy.jobs.expressions;

// Generated by TinyPG v1.2 available at www.codeproject.com


public class Parser
{
	private Scanner scanner;
	private ParseTree tree;

	public Parser(Scanner scanner)
	{
		this.scanner = scanner;
	}

	public final ParseTree Parse(String input)
	{
		tree = new ParseTree();
		return Parse(input, tree);
	}

	public final ParseTree Parse(String input, ParseTree tree)
	{
		scanner.Init(input);

		this.tree = tree;
		ParseStart(tree);
		tree.Skipped = scanner.Skipped;

		return tree;
	}

	private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
		parent.getNodes().add(node);


		 // Concat Rule
		tok = scanner.LookAhead(TokenType.NOT, TokenType.BROPEN, TokenType.NEGETIVE, TokenType.BOOL, TokenType.STRING, TokenType.INTEGER, TokenType.DECIMAL, TokenType.HEX, TokenType.IDENTITY); // Option Rule
		if (tok.Type == TokenType.NOT || tok.Type == TokenType.BROPEN || tok.Type == TokenType.NEGETIVE || tok.Type == TokenType.BOOL || tok.Type == TokenType.STRING || tok.Type == TokenType.INTEGER || tok.Type == TokenType.DECIMAL || tok.Type == TokenType.HEX || tok.Type == TokenType.IDENTITY)
		{
			ParseOrExpr(node); // NonTerminal Rule: OrExpr
		}

		 // Concat Rule
		tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
		if (tok.Type != TokenType.EOF)
		{
			tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.EOF.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
		}
		n = node.CreateNode(tok, tok.toString());
		node.Token.UpdateRange(tok);
		node.getNodes().add(n);

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: Start

	private void ParseOrExpr(ParseNode parent) // NonTerminalSymbol: OrExpr
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OrExpr), "OrExpr");
		parent.getNodes().add(node);


		 // Concat Rule
		ParseAndExpr(node); // NonTerminal Rule: AndExpr

		 // Concat Rule
		tok = scanner.LookAhead(TokenType.OR); // ZeroOrMore Rule
		while (tok.Type == TokenType.OR)
		{

			 // Concat Rule
			tok = scanner.Scan(TokenType.OR); // Terminal Rule: OR
			if (tok.Type != TokenType.OR)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.OR.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);

			 // Concat Rule
			ParseAndExpr(node); // NonTerminal Rule: AndExpr
		tok = scanner.LookAhead(TokenType.OR); // ZeroOrMore Rule
		}

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: OrExpr

	private void ParseAndExpr(ParseNode parent) // NonTerminalSymbol: AndExpr
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AndExpr), "AndExpr");
		parent.getNodes().add(node);


		 // Concat Rule
		ParseNotExpr(node); // NonTerminal Rule: NotExpr

		 // Concat Rule
		tok = scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
		while (tok.Type == TokenType.AND)
		{

			 // Concat Rule
			tok = scanner.Scan(TokenType.AND); // Terminal Rule: AND
			if (tok.Type != TokenType.AND)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.AND.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);

			 // Concat Rule
			ParseNotExpr(node); // NonTerminal Rule: NotExpr
		tok = scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
		}

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: AndExpr

	private void ParseNotExpr(ParseNode parent) // NonTerminalSymbol: NotExpr
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NotExpr), "NotExpr");
		parent.getNodes().add(node);


		 // Concat Rule
		tok = scanner.LookAhead(TokenType.NOT); // Option Rule
		if (tok.Type == TokenType.NOT)
		{
			tok = scanner.Scan(TokenType.NOT); // Terminal Rule: NOT
			if (tok.Type != TokenType.NOT)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.NOT.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);
		}

		 // Concat Rule
		ParseCompareExpr(node); // NonTerminal Rule: CompareExpr

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: NotExpr

	private void ParseCompareExpr(ParseNode parent) // NonTerminalSymbol: CompareExpr
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CompareExpr), "CompareExpr");
		parent.getNodes().add(node);


		 // Concat Rule
		ParseAddExpr(node); // NonTerminal Rule: AddExpr

		 // Concat Rule
		tok = scanner.LookAhead(TokenType.COMPARER); // ZeroOrMore Rule
		while (tok.Type == TokenType.COMPARER)
		{

			 // Concat Rule
			tok = scanner.Scan(TokenType.COMPARER); // Terminal Rule: COMPARER
			if (tok.Type != TokenType.COMPARER)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.COMPARER.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);

			 // Concat Rule
			ParseAddExpr(node); // NonTerminal Rule: AddExpr
		tok = scanner.LookAhead(TokenType.COMPARER); // ZeroOrMore Rule
		}

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: CompareExpr

	private void ParseAddExpr(ParseNode parent) // NonTerminalSymbol: AddExpr
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddExpr), "AddExpr");
		parent.getNodes().add(node);


		 // Concat Rule
		ParseMultExpr(node); // NonTerminal Rule: MultExpr

		 // Concat Rule
		tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
		while (tok.Type == TokenType.PLUSMINUS)
		{

			 // Concat Rule
			tok = scanner.Scan(TokenType.PLUSMINUS); // Terminal Rule: PLUSMINUS
			if (tok.Type != TokenType.PLUSMINUS)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);

			 // Concat Rule
			ParseMultExpr(node); // NonTerminal Rule: MultExpr
		tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
		}

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: AddExpr

	private void ParseMultExpr(ParseNode parent) // NonTerminalSymbol: MultExpr
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultExpr), "MultExpr");
		parent.getNodes().add(node);


		 // Concat Rule
		ParseCastExpr(node); // NonTerminal Rule: CastExpr

		 // Concat Rule
		tok = scanner.LookAhead(TokenType.MULTDIV); // ZeroOrMore Rule
		while (tok.Type == TokenType.MULTDIV)
		{

			 // Concat Rule
			tok = scanner.Scan(TokenType.MULTDIV); // Terminal Rule: MULTDIV
			if (tok.Type != TokenType.MULTDIV)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.MULTDIV.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);

			 // Concat Rule
			ParseCastExpr(node); // NonTerminal Rule: CastExpr
		tok = scanner.LookAhead(TokenType.MULTDIV); // ZeroOrMore Rule
		}

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: MultExpr

	private void ParseCastExpr(ParseNode parent) // NonTerminalSymbol: CastExpr
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CastExpr), "CastExpr");
		parent.getNodes().add(node);


		 // Concat Rule
		tok = scanner.LookAhead(TokenType.BROPEN); // ZeroOrMore Rule
		while (tok.Type == TokenType.BROPEN)
		{

			 // Concat Rule
			tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
			if (tok.Type != TokenType.BROPEN)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.BROPEN.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);

			 // Concat Rule
			tok = scanner.Scan(TokenType.IDENTITY); // Terminal Rule: IDENTITY
			if (tok.Type != TokenType.IDENTITY)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.IDENTITY.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);

			 // Concat Rule
			tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
			while (tok.Type == TokenType.DOT)
			{

				 // Concat Rule
				tok = scanner.Scan(TokenType.DOT); // Terminal Rule: DOT
				if (tok.Type != TokenType.DOT)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.DOT.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);

				 // Concat Rule
				tok = scanner.Scan(TokenType.IDENTITY); // Terminal Rule: IDENTITY
				if (tok.Type != TokenType.IDENTITY)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.IDENTITY.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);
			tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
			}

			 // Concat Rule
			tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
			if (tok.Type != TokenType.BRCLOSE)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);
		tok = scanner.LookAhead(TokenType.BROPEN); // ZeroOrMore Rule
		}

		 // Concat Rule
		ParseNegetiveExpr(node); // NonTerminal Rule: NegetiveExpr

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: CastExpr

	private void ParseNegetiveExpr(ParseNode parent) // NonTerminalSymbol: NegetiveExpr
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NegetiveExpr), "NegetiveExpr");
		parent.getNodes().add(node);


		 // Concat Rule
		tok = scanner.LookAhead(TokenType.NEGETIVE); // Option Rule
		if (tok.Type == TokenType.NEGETIVE)
		{
			tok = scanner.Scan(TokenType.NEGETIVE); // Terminal Rule: NEGETIVE
			if (tok.Type != TokenType.NEGETIVE)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.NEGETIVE.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);
		}

		 // Concat Rule
		ParseAtom(node); // NonTerminal Rule: Atom

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: NegetiveExpr

	private void ParseAtom(ParseNode parent) // NonTerminalSymbol: Atom
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Atom), "Atom");
		parent.getNodes().add(node);

		tok = scanner.LookAhead(TokenType.BOOL, TokenType.STRING, TokenType.INTEGER, TokenType.DECIMAL, TokenType.HEX, TokenType.IDENTITY, TokenType.BROPEN); // Choice Rule
		switch (tok.Type)
		{ // Choice Rule
			case BOOL:
				tok = scanner.Scan(TokenType.BOOL); // Terminal Rule: BOOL
				if (tok.Type != TokenType.BOOL)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.BOOL.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);
				break;
			case STRING:
				tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
				if (tok.Type != TokenType.STRING)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.STRING.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);
				break;
			case INTEGER:
			case DECIMAL:
			case HEX:
				ParseNumber(node); // NonTerminal Rule: Number
				break;
			case IDENTITY:
				ParseFunction(node); // NonTerminal Rule: Function
				break;
			case BROPEN:

				 // Concat Rule
				tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
				if (tok.Type != TokenType.BROPEN)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.BROPEN.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);

				 // Concat Rule
				ParseOrExpr(node); // NonTerminal Rule: OrExpr

				 // Concat Rule
				tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
				if (tok.Type != TokenType.BRCLOSE)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);
				break;
			default:
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found.", 0x0002, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				break;
		} // Choice Rule

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: Atom

	private void ParseNumber(ParseNode parent) // NonTerminalSymbol: Number
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Number), "Number");
		parent.getNodes().add(node);

		tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DECIMAL, TokenType.HEX); // Choice Rule
		switch (tok.Type)
		{ // Choice Rule
			case INTEGER:
				tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
				if (tok.Type != TokenType.INTEGER)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.INTEGER.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);
				break;
			case DECIMAL:
				tok = scanner.Scan(TokenType.DECIMAL); // Terminal Rule: DECIMAL
				if (tok.Type != TokenType.DECIMAL)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.DECIMAL.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);
				break;
			case HEX:
				tok = scanner.Scan(TokenType.HEX); // Terminal Rule: HEX
				if (tok.Type != TokenType.HEX)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.HEX.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);
				break;
			default:
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found.", 0x0002, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				break;
		} // Choice Rule

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: Number

	private void ParseFunction(ParseNode parent) // NonTerminalSymbol: Function
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Function), "Function");
		parent.getNodes().add(node);


		 // Concat Rule
		tok = scanner.Scan(TokenType.IDENTITY); // Terminal Rule: IDENTITY
		if (tok.Type != TokenType.IDENTITY)
		{
			tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.IDENTITY.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
		}
		n = node.CreateNode(tok, tok.toString());
		node.Token.UpdateRange(tok);
		node.getNodes().add(n);

		 // Concat Rule
		tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
		while (tok.Type == TokenType.DOT)
		{

			 // Concat Rule
			tok = scanner.Scan(TokenType.DOT); // Terminal Rule: DOT
			if (tok.Type != TokenType.DOT)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.DOT.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);

			 // Concat Rule
			tok = scanner.Scan(TokenType.IDENTITY); // Terminal Rule: IDENTITY
			if (tok.Type != TokenType.IDENTITY)
			{
				tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.IDENTITY.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
			}
			n = node.CreateNode(tok, tok.toString());
			node.Token.UpdateRange(tok);
			node.getNodes().add(n);
		tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
		}

		 // Concat Rule
		tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
		if (tok.Type != TokenType.BROPEN)
		{
			tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.BROPEN.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
		}
		n = node.CreateNode(tok, tok.toString());
		node.Token.UpdateRange(tok);
		node.getNodes().add(n);

		 // Concat Rule
		ParseArguments(node); // NonTerminal Rule: Arguments

		 // Concat Rule
		tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
		if (tok.Type != TokenType.BRCLOSE)
		{
			tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
		}
		n = node.CreateNode(tok, tok.toString());
		node.Token.UpdateRange(tok);
		node.getNodes().add(n);

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: Function

	private void ParseArguments(ParseNode parent) // NonTerminalSymbol: Arguments
	{
		Token tok;
		ParseNode n;
		ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Arguments), "Arguments");
		parent.getNodes().add(node);

		tok = scanner.LookAhead(TokenType.NOT, TokenType.BROPEN, TokenType.NEGETIVE, TokenType.BOOL, TokenType.STRING, TokenType.INTEGER, TokenType.DECIMAL, TokenType.HEX, TokenType.IDENTITY); // Option Rule
		if (tok.Type == TokenType.NOT || tok.Type == TokenType.BROPEN || tok.Type == TokenType.NEGETIVE || tok.Type == TokenType.BOOL || tok.Type == TokenType.STRING || tok.Type == TokenType.INTEGER || tok.Type == TokenType.DECIMAL || tok.Type == TokenType.HEX || tok.Type == TokenType.IDENTITY)
		{

			 // Concat Rule
			ParseOrExpr(node); // NonTerminal Rule: OrExpr

			 // Concat Rule
			tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
			while (tok.Type == TokenType.COMMA)
			{

				 // Concat Rule
				tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
				if (tok.Type != TokenType.COMMA)
				{
					tree.Errors.add(new ParseError("Unexpected token '" + tok.getText().replace("\n", "") + "' found. Expected " + TokenType.COMMA.toString(), 0x1001, 0, tok.getStartPos(), tok.getStartPos(), tok.getLength()));
				}
				n = node.CreateNode(tok, tok.toString());
				node.Token.UpdateRange(tok);
				node.getNodes().add(n);

				 // Concat Rule
				ParseOrExpr(node); // NonTerminal Rule: OrExpr
			tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
			}
		}

		parent.Token.UpdateRange(node.Token);
	} // NonTerminalSymbol: Arguments


}