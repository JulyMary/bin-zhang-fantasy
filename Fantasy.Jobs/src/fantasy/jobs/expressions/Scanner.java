package fantasy.jobs.expressions;

import java.util.Arrays;
import java.util.regex.*;

// Generated by TinyPG v1.2 available at www.codeproject.com


public class Scanner
{
	public String Input;
	public int StartPos = 0;
	public int EndPos = 0;
	public int CurrentLine;
	public int CurrentColumn;
	public int CurrentPosition;
	public java.util.ArrayList<Token> Skipped; // tokens that were skipped
	public java.util.HashMap<TokenType, Pattern> Patterns;

	private Token LookAheadToken;
	private java.util.ArrayList<TokenType> Tokens;
	private java.util.ArrayList<TokenType> SkipList; // tokens to be skipped

	public Scanner()
	{
		Pattern regex;
		this.Patterns = new java.util.HashMap<TokenType, Pattern>();
		this.Tokens = new java.util.ArrayList<TokenType>();
		this.LookAheadToken = null;

		SkipList = new java.util.ArrayList<TokenType>();
		SkipList.add(TokenType.WHITESPACE);

		regex = Pattern.compile("^\\s*$");
		Patterns.put(TokenType.EOF, regex);
		Tokens.add(TokenType.EOF);

		regex = Pattern.compile("@?'(\\\\'|[^'])*\\'");
		Patterns.put(TokenType.STRING, regex);
		Tokens.add(TokenType.STRING);

		regex = Pattern.compile("\\d+");
		Patterns.put(TokenType.INTEGER, regex);
		Tokens.add(TokenType.INTEGER);

		regex = Pattern.compile("\\d+((f|F)|\\.\\d+(f|F)?)");
		Patterns.put(TokenType.DECIMAL, regex);
		Tokens.add(TokenType.DECIMAL);

		regex = Pattern.compile("0x((?i)[a-f\\d]\\+)");
		Patterns.put(TokenType.HEX, regex);
		Tokens.add(TokenType.HEX);

		regex = Pattern.compile("\\+|\\-");
		Patterns.put(TokenType.PLUSMINUS, regex);
		Tokens.add(TokenType.PLUSMINUS);

		regex = Pattern.compile("\\-");
		Patterns.put(TokenType.NEGETIVE, regex);
		Tokens.add(TokenType.NEGETIVE);

		regex = Pattern.compile("\\*|\\\\|%|/");
		Patterns.put(TokenType.MULTDIV, regex);
		Tokens.add(TokenType.MULTDIV);

		regex = Pattern.compile("\\(");
		Patterns.put(TokenType.BROPEN, regex);
		Tokens.add(TokenType.BROPEN);

		regex = Pattern.compile("\\)");
		Patterns.put(TokenType.BRCLOSE, regex);
		Tokens.add(TokenType.BRCLOSE);

		regex = Pattern.compile("(?i)(?!(and|or|not|true|false)(\\W|$))\\w+");
		Patterns.put(TokenType.IDENTITY, regex);
		Tokens.add(TokenType.IDENTITY);

		regex = Pattern.compile("(?i)and");
		Patterns.put(TokenType.AND, regex);
		Tokens.add(TokenType.AND);

		regex = Pattern.compile("(?i)or");
		Patterns.put(TokenType.OR, regex);
		Tokens.add(TokenType.OR);

		regex = Pattern.compile("(?i)not");
		Patterns.put(TokenType.NOT, regex);
		Tokens.add(TokenType.NOT);

		regex = Pattern.compile(">=|>|<=|<|==|!=");
		Patterns.put(TokenType.COMPARER, regex);
		Tokens.add(TokenType.COMPARER);

		regex = Pattern.compile(",");
		Patterns.put(TokenType.COMMA, regex);
		Tokens.add(TokenType.COMMA);

		regex = Pattern.compile("\\.|\\+");
		Patterns.put(TokenType.DOT, regex);
		Tokens.add(TokenType.DOT);

		regex = Pattern.compile("(?i)true|false");
		Patterns.put(TokenType.BOOL, regex);
		Tokens.add(TokenType.BOOL);

		regex = Pattern.compile("\\s+");
		Patterns.put(TokenType.WHITESPACE, regex);
		Tokens.add(TokenType.WHITESPACE);


	}

	public final void Init(String input)
	{
		this.Input = input;
		StartPos = 0;
		EndPos = 0;
		CurrentLine = 0;
		CurrentColumn = 0;
		CurrentPosition = 0;
		Skipped = new java.util.ArrayList<Token>();
		LookAheadToken = null;
	}

	public final Token GetToken(TokenType type)
	{
		Token t = new Token(this.StartPos, this.EndPos);
		t.Type = type;
		return t;
	}

	 /** 
	 executes a lookahead of the next token
	 and will advance the scan on the input string
	 
	 @return 
	 */
	public final Token Scan(TokenType... expectedtokens)
	{
		Token tok = LookAhead(expectedtokens); // temporarely retrieve the lookahead
		LookAheadToken = null; // reset lookahead token, so scanning will continue
		StartPos = tok.getEndPos();
		EndPos = tok.getEndPos(); // set the tokenizer to the new scan position
		return tok;
	}

	/** 
	 returns token with longest best match
	 
	 @return 
	*/
	public final Token LookAhead(TokenType... expectedtokens)
	{
		int i;
		int startpos = StartPos;
		Token tok = null;
		java.util.ArrayList<TokenType> scantokens;


		// this prevents double scanning and matching
		// increased performance
		if (LookAheadToken != null && LookAheadToken.Type != TokenType._UNDETERMINED_ && LookAheadToken.Type != TokenType._NONE_)
		{
			return LookAheadToken;
		}

		// if no scantokens specified, then scan for all of them (= backward compatible)
		if (expectedtokens.length == 0)
		{
			scantokens = Tokens;
		}
		else
		{
			scantokens = new java.util.ArrayList<TokenType>(Arrays.asList(expectedtokens));
			scantokens.addAll(SkipList);
		}

		do
		{

			int len = -1;
			TokenType index = TokenType.Absurd;
			String input = Input.substring(startpos);

			tok = new Token(startpos, EndPos);

			for (i = 0; i < scantokens.size(); i++)
			{
				Pattern r = Patterns.get(scantokens.get(i));
				Matcher m = r.matcher(input);
				if (m.lookingAt() && m.start() == 0 && ((m.end() - m.start() > len) || (scantokens.get(i).getValue() < index.getValue() && m.end() - m.start() == len)))
				{
					len = m.end() - m.start();
					index = scantokens.get(i);
				}
			}

			if (index.getValue() >= 0 && len >= 0)
			{
				tok.setEndPos(startpos + len);
				tok.setText(Input.substring(tok.getStartPos(), tok.getStartPos() + len));
				tok.Type = index;
			}
			else
			{
				if (tok.getStartPos() < tok.getEndPos() - 1)
				{
					tok.setText(Input.substring(tok.getStartPos(), tok.getStartPos() + 1));
				}
			}

			if (SkipList.contains(tok.Type))
			{
				startpos = tok.getEndPos();
				Skipped.add(tok);
			}
		}
		while (SkipList.contains(tok.Type));

		LookAheadToken = tok;
		return tok;
	}
}