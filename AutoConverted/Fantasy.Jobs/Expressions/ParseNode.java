package Fantasy.Jobs.Expressions;

import Fantasy.Jobs.Properties.*;

// Generated by TinyPG v1.2 available at www.codeproject.com




public class ParseNode
{
	protected String text;
	protected java.util.ArrayList<ParseNode> nodes;

	public final java.util.ArrayList<ParseNode> getNodes()
	{
		return nodes;
	}

	public ParseNode Parent;
	public Token Token; // the token/rule
	public final String getText()
	{
		return text;
	}
	public final void setText(String value)
	{
		text = value;
	}

	public ParseNode CreateNode(Token token, String text)
	{
		ParseNode node = new ParseNode(token, text);
		node.Parent = this;
		return node;
	}

	protected ParseNode(Token token, String text)
	{
		this.Token = token;
		this.text = text;
		this.nodes = new java.util.ArrayList<ParseNode>();
	}

	protected final Object GetValue(ParseTree tree, TokenType type, int index)
	{
		RefObject<Integer> tempRef_index = new RefObject<Integer>(index);
		Object tempVar = GetValue(tree, type, tempRef_index);
		index = tempRef_index.argvalue;
		return tempVar;
	}

	protected final Object GetValue(ParseTree tree, TokenType type, RefObject<Integer> index)
	{
		Object o = null;
		if (index.argvalue < 0)
		{
			return o;
		}

		// left to right
		for (ParseNode node : nodes)
		{
			if (node.Token.Type == type)
			{
				index.argvalue--;
				if (index.argvalue < 0)
				{
					o = node.Eval(tree);
					break;
				}
			}
		}
		return o;
	}

	/** 
	 this implements the evaluation functionality, cannot be used directly
	 
	 @param tree the parsetree itself
	 @param paramlist optional input parameters
	 @return a partial result of the evaluation
	*/
	public final Object Eval(ParseTree tree, Object... paramlist)
	{
		Object Value = null;

		switch (Token.Type)
		{
			case Start:
				Value = EvalStart(tree, paramlist);
				break;
			case OrExpr:
				Value = EvalOrExpr(tree, paramlist);
				break;
			case AndExpr:
				Value = EvalAndExpr(tree, paramlist);
				break;
			case NotExpr:
				Value = EvalNotExpr(tree, paramlist);
				break;
			case CompareExpr:
				Value = EvalCompareExpr(tree, paramlist);
				break;
			case AddExpr:
				Value = EvalAddExpr(tree, paramlist);
				break;
			case MultExpr:
				Value = EvalMultExpr(tree, paramlist);
				break;
			case CastExpr:
				Value = EvalCastExpr(tree, paramlist);
				break;
			case NegetiveExpr:
				Value = EvalNegetiveExpr(tree, paramlist);
				break;
			case Atom:
				Value = EvalAtom(tree, paramlist);
				break;
			case Number:
				Value = EvalNumber(tree, paramlist);
				break;
			case Function:
				Value = EvalFunction(tree, paramlist);
				break;
			case Arguments:
				Value = EvalArguments(tree, paramlist);
				break;
			case STRING:
				Value = EvalSTRING(tree, paramlist);
				break;
			case INTEGER:
				Value = EvalINTEGER(tree, paramlist);
				break;
			case HEX:
				Value = EvalHex(tree, paramlist);
				break;
			case DECIMAL:
				Value = EvalDECIMAL(tree, paramlist);
				break;
			case BOOL :
				Value = EvalBOOL(tree, paramlist);
				break;
			default:
				Value = Token.getText();
				break;
		}
		return Value;
	}






	private int GetTokenCount(TokenType tokenType)
	{
//C# TO JAVA CONVERTER TODO TASK: There is no Java equivalent to LINQ queries:
		return (from node in this.getNodes() where node.Token.Type == tokenType select node).Count();
	}


	private Object EvalDECIMAL(ParseTree tree, Object[] paramlist)
	{
		String s = DotNetToJavaStringHelper.trimEnd(this.Token.getText(), 'f', 'F');
		return java.math.BigDecimal.Parse(s);
	}

	private Object EvalHex(ParseTree tree, Object[] paramlist)
	{
		String s = this.Token.getText().substring(2);
		return Integer.parseInt(s, 16);

	}

	private Object EvalINTEGER(ParseTree tree, Object[] paramlist)
	{
		return Integer.parseInt(this.Token.getText());
	}

	private Object EvalSTRING(ParseTree tree, Object[] paramlist)
	{
		Regex reg = new Regex("\\\\(0x(?<hex4>[0-9a-fA-F]{4})|0x(?<hex2>[0-9a-fA-F]{2})|(?<oct>[0-7]{3})|(?<char>.?))");

		String text = this.Token.getText();
		if (text.startsWith("@"))
		{
			char quotation = text.charAt(1);
			String rs = text.substring(2, 2 + text.length() - 3).Replace(new String(quotation,2), (new Character(quotation)).toString());
			return rs;
		}
		else
		{
			text = text.substring(1, 1 + text.length() - 2);
			StringBuilder rs = new StringBuilder();
			int s = 0;
			while (s < text.length())
			{
				Match m = reg.Match(text, s);
				if (m.Success)
				{
					rs.append(text.substring(s, m.Index));

					char value;
					if (m.Groups["hex4"].Success)
					{
						value = Convert.ToChar(Integer.parseInt(m.Groups["hex4"].getValue(), 16));
					}
					else if (m.Groups["hex2"].Success)
					{
						value = Convert.ToChar(Integer.parseInt(m.Groups["hex2"].getValue(), 16));
					}
					else if (m.Groups["oct"].Success)
					{
						value = Convert.ToChar(Integer.parseInt(m.Groups["oct"].getValue(), 8));
					}
					else
					{
//C# TO JAVA CONVERTER NOTE: The following 'switch' operated on a string member and was converted to Java 'if-else' logic:
//						switch (m.Groups["char"].Value)
//ORIGINAL LINE: case "a":
						if (m.Groups["char"].getValue().equals("a"))
						{
								value = '\a';
						}
//ORIGINAL LINE: case "b":
						else if (m.Groups["char"].getValue().equals("b"))
						{
								value = '\b';
						}
//ORIGINAL LINE: case "f":
						else if (m.Groups["char"].getValue().equals("f"))
						{
								value = '\f';
						}
//ORIGINAL LINE: case "n":
						else if (m.Groups["char"].getValue().equals("n"))
						{
								value = '\n';
						}
//ORIGINAL LINE: case "r":
						else if (m.Groups["char"].getValue().equals("r"))
						{
								value = '\r';
						}
//ORIGINAL LINE: case "t":
						else if (m.Groups["char"].getValue().equals("t"))
						{
								value = '\t';
						}
//ORIGINAL LINE: case "v":
						else if (m.Groups["char"].getValue().equals("v"))
						{
								value = '\v';
						}
//ORIGINAL LINE: case "'":
						else if (m.Groups["char"].getValue().equals("'"))
						{
								value = '\'';
						}
//ORIGINAL LINE: case "\\":
						else if (m.Groups["char"].getValue().equals("\\"))
						{
								value = '\\';
						}
						else
						{
								throw new InvalidOperationException(String.format("Unrecognized escape sequences in string '%1$s'.", text));

						}
					}
					rs.append(value);
					s = m.Index + m.getLength();
				}
				else
				{
					rs.append(text.substring(s));
					s = text.length();
				}
			}

			return rs.toString();
		}



	}

	protected Object EvalStart(ParseTree tree, Object... paramlist)
	{
		if (this.GetTokenCount(TokenType.OrExpr) == 1)
		{
			return this.GetValue(tree, TokenType.OrExpr, 0);
		}
		else
		{
			return null;
		}

	}

	protected Object EvalOrExpr(ParseTree tree, Object... paramlist)
	{
		int count = this.GetTokenCount(TokenType.AndExpr);
		if (count == 1)
		{
			return this.GetValue(tree, TokenType.AndExpr, 0);
		}
		else
		{
			for (int i = 0; i < count; i++)
			{
				if ((boolean)this.GetValue(tree, TokenType.AndExpr, i))
				{
					return true;
				}
			}
			return false;
		}
	}

	protected Object EvalAndExpr(ParseTree tree, Object... paramlist)
	{
		int count = this.GetTokenCount(TokenType.NotExpr);
		if (count == 1)
		{
			return this.GetValue(tree, TokenType.NotExpr, 0);
		}
		else
		{
			for (int i = 0; i < count; i++)
			{
				if (!(boolean)this.GetValue(tree, TokenType.NotExpr, i))
				{
					return false;
				}
			}
			return true;
		}
	}

	protected Object EvalNotExpr(ParseTree tree, Object... paramlist)
	{
		Object value = this.GetValue(tree, TokenType.CompareExpr, 0);
		if (this.GetTokenCount(TokenType.NOT) == 1)
		{
			return !((Boolean)value).booleanValue();
		}
		else
		{
			return value;
		}
	}

	protected Object EvalCompareExpr(ParseTree tree, Object... paramlist)
	{
		int count = this.GetTokenCount(TokenType.AddExpr);

		Object rs = this.GetValue(tree, TokenType.AddExpr, 0);
		for (int i = 1; i < count; i++)
		{
			Object val = this.GetValue(tree, TokenType.AddExpr, 1);
			int cmp = Comparer.Default.Compare(rs, val);
//C# TO JAVA CONVERTER NOTE: The following 'switch' operated on a string member and was converted to Java 'if-else' logic:
//			switch ((string)this.GetValue(tree, TokenType.COMPARER, i - 1))
//ORIGINAL LINE: case ">=":
			if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1).equals(">="))
			{
					rs = cmp >= 0;
			}
//ORIGINAL LINE: case ">":
			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1).equals(">"))
			{
					rs = cmp > 0;
			}
//ORIGINAL LINE: case "<=":
			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1).equals("<="))
			{
					rs = cmp <= 0;
			}
//ORIGINAL LINE: case "<":
			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1).equals("<"))
			{
					rs = cmp < 0;
			}
//ORIGINAL LINE: case "==":
			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1).equals("=="))
			{
					rs = cmp == 0;
			}
//ORIGINAL LINE: case "!=":
			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1).equals("!="))
			{
					rs = cmp != 0;
			}
			else
			{
					throw new RuntimeException("Absurd");
			}
		}
		return rs;

	}

	private String EvalType(Object value)
	{

		switch (Convert.GetTypeCode(value))
		{
			case TypeCode.Byte:
			case TypeCode.SByte:
			case TypeCode.Int16:
			case TypeCode.Int32:
			case TypeCode.Int64:
			case TypeCode.UInt16:
			case TypeCode.UInt32:
			case TypeCode.UInt64:
				return "int";
			case TypeCode.Decimal:
			case TypeCode.Double:
			case TypeCode.Single:
				return "dec";
			case TypeCode.String:
			case TypeCode.Char:
			case TypeCode.Empty:
				return "str";
			default:
				return "un";

		}
	}

	protected Object EvalAddExpr(ParseTree tree, Object... paramlist)
	{
		int count = this.GetTokenCount(TokenType.MultExpr);
		if (count > 1)
		{

			Object rs = null;
			String oldType = "un";
			for (int i = 0; i < count; i++)
			{
				Object o = this.GetValue(tree, TokenType.MultExpr, i);
				if (i == 0)
				{
					rs = o;
					oldType = EvalType(rs);
				}
				else
				{

					String newType = EvalType(o);
					int op = (String)this.GetValue(tree, TokenType.PLUSMINUS, i - 1).equals("+") ? 1 : -1;

					if (oldType.equals("int") && newType.equals("int"))
					{
						rs = ((Integer)rs).intValue() + op * ((Integer)o).intValue();
					}
					else if (oldType.equals("int") && newType.equals("dec"))
					{
						rs = (java.math.BigDecimal)rs + op * (java.math.BigDecimal)o;
						oldType = "dec";
					}
					else if (oldType.equals("dec") && (newType.equals("dec") || newType.equals("int")))
					{
						rs = (java.math.BigDecimal)rs + op * (java.math.BigDecimal)o;
					}
					else if (oldType.equals("str") && newType.equals("str"))
					{
						if (op == 1)
						{
							rs = (String)rs + (String)o;
						}
						else
						{
							throw new InvalidOperationException(Properties.Resources.getDoNotSupportMinusStringText());
						}
					}
					else
					{
						throw new InvalidOperationException(String.format(Properties.Resources.getDoNotSupportPlusText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
					}

				}
			}

			return rs;
		}
		else
		{
			return this.GetValue(tree, TokenType.MultExpr, 0);
		}

	}

	protected Object EvalMultExpr(ParseTree tree, Object... paramlist)
	{
		int count = this.GetTokenCount(TokenType.CastExpr);
		if (count > 1)
		{
			Object rs = null;
			String oldType = "un";
			for (int i = 0; i < count; i++)
			{
				Object o = this.GetValue(tree, TokenType.CastExpr, i);
				if (i == 0)
				{
					rs = o;
					oldType = EvalType(rs);
				}
				else
				{

					String newType = EvalType(o);
					String op = (String)this.GetValue(tree, TokenType.MULTDIV, i - 1);

//C# TO JAVA CONVERTER NOTE: The following 'switch' operated on a string member and was converted to Java 'if-else' logic:
//					switch (op)
//ORIGINAL LINE: case "\\":
					if (op.equals("\\"))
					{
							if (oldType.equals("int") && newType.equals("int"))
							{
								rs = ((Integer)rs).intValue() / ((Integer)o).intValue();
							}
							else
							{
								throw new InvalidOperationException(String.format(Properties.Resources.getDoNotSupportDivideExactlyText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
							}
					}
//ORIGINAL LINE: case "%":
					else if (op.equals("%"))
					{
							if (oldType.equals("int") && newType.equals("int"))
							{
								rs = ((Integer)rs).intValue() % ((Integer)o).intValue();
							}
							else
							{
								throw new InvalidOperationException(String.format(Properties.Resources.getDoNotSupportModulusText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
							}
					}
//ORIGINAL LINE: case "/":
					else if (op.equals("/"))
					{
							if (oldType.equals("int") && newType.equals("int"))
							{
								rs = ((Integer)rs).intValue() / ((Integer)o).intValue();
							}
							else if ((oldType.equals("int") || oldType.equals("dec")) && (newType.equals("int") || newType.equals("dec")))
							{
								rs = (java.math.BigDecimal)rs / (java.math.BigDecimal)o;
								oldType = "dec";
							}
							else
							{
								throw new InvalidOperationException(String.format(Properties.Resources.getDoNotSupportMultDivText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
							}
					}
//ORIGINAL LINE: case "*":
					else if (op.equals("*"))
					{
							if (oldType.equals("int") && newType.equals("int"))
							{
								rs = ((Integer)rs).intValue() * ((Integer)o).intValue();
							}
							else if ((oldType.equals("int") || oldType.equals("dec")) && (newType.equals("int") || newType.equals("dec")))
							{
								rs = (java.math.BigDecimal)rs * (java.math.BigDecimal)o;
								oldType = "dec";
							}
							else
							{
								throw new InvalidOperationException(String.format(Properties.Resources.getDoNotSupportMultDivText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
							}
					}

				}
			}

			return rs;
		}
		else
		{
			return this.GetValue(tree, TokenType.CastExpr, 0);
		}
	}

	protected Object EvalNegetiveExpr(ParseTree tree, Object... paramlist)
	{
		Object rs = this.GetValue(tree, TokenType.Atom, 0);
		if ((String)this.GetValue(tree, TokenType.NEGETIVE, 0).equals("-"))
		{
			String type = this.EvalType(rs);
//C# TO JAVA CONVERTER NOTE: The following 'switch' operated on a string member and was converted to Java 'if-else' logic:
//			switch (type)
//ORIGINAL LINE: case "int":
			if (type.equals("int"))
			{
					return -((Integer)rs).intValue();
			}
//ORIGINAL LINE: case "dec":
			else if (type.equals("dec"))
			{
					return -(java.math.BigDecimal)rs;
			}
			else
			{
					throw new InvalidOperationException(String.format(Properties.Resources.getDoNotSupportNagetiveText(), (rs != null) ? rs : "null"));
			}
		}
		else
		{
			return rs;
		}
	}

	protected Object EvalAtom(ParseTree tree, Object... paramlist)
	{
		if (this.GetTokenCount(TokenType.STRING) == 1)
		{
			return this.GetValue(tree, TokenType.STRING, 0);
		}
		else if (this.GetTokenCount(TokenType.Number) == 1)
		{
			return this.GetValue(tree, TokenType.Number, 0);
		}
		else if (this.GetTokenCount(TokenType.Function) == 1)
		{
			return this.GetValue(tree, TokenType.Function, 0);
		}
		else if (this.GetTokenCount(TokenType.BOOL) == 1)
		{
			return this.GetValue(tree, TokenType.BOOL, 0);
		}
		else
		{
			return this.GetValue(tree, TokenType.OrExpr, 0);
		}
	}

	protected Object EvalNumber(ParseTree tree, Object... paramlist)
	{
		if (this.GetTokenCount(TokenType.INTEGER) == 1)
		{
			return this.GetValue(tree, TokenType.INTEGER, 0);
		}
		if (this.GetTokenCount(TokenType.DECIMAL) == 1)
		{
			return this.GetValue(tree, TokenType.DECIMAL, 0);
		}
		else
		{
			return this.GetValue(tree, TokenType.HEX, 0);
		}
	}

	protected Object EvalFunction(ParseTree tree, Object... paramlist)
	{
		int count = this.GetTokenCount(TokenType.IDENTITY);

		String method = (String)this.GetValue(tree, TokenType.IDENTITY, count - 1);

		StringBuilder typeName = new StringBuilder();
		for (int i = 0; i < count - 1; i++)
		{
			if (i > 0)
			{
				typeName.append(this.GetValue(tree, TokenType.DOT, i));
			}
			typeName.append(this.GetValue(tree, TokenType.IDENTITY, i));

		}


		java.lang.Class t = this.ResolveType(typeName.toString());
		Object[] args = (Object[])this.GetValue(tree, TokenType.Arguments, 0);
		return tree.OnInvokeFunction(t, method, args);

	}

	protected Object EvalArguments(ParseTree tree, Object... paramlist)
	{
		int count = this.GetTokenCount(TokenType.OrExpr);
		Object[] rs = new Object[count];
		for (int i = 0; i < count; i++)
		{
			rs[i] = this.GetValue(tree, TokenType.OrExpr, i);
		}

		return rs;
	}

	protected Object EvalCastExpr(ParseTree tree, Object... paramlist)
	{
		Object value = this.GetValue(tree, TokenType.NegetiveExpr, 0);
		int count = this.GetTokenCount(TokenType.IDENTITY);
		if (count > 0)
		{
			StringBuilder typeName = new StringBuilder();
			for (int i = 0; i < count; i++)
			{
				typeName.append(this.GetValue(tree, TokenType.IDENTITY, i));
				if (i > 0)
				{
					typeName.append(this.GetValue(tree, TokenType.DOT, i-1));
				}
			}

			java.lang.Class t = ResolveType(typeName.toString());

			value = Convert.ChangeType(value, t);
		}

		return value;

	}

	private Object EvalBOOL(ParseTree tree, Object[] paramlist)
	{
		return Boolean.parseBoolean(this.Token.getText());
	}

	protected final java.lang.Class ResolveType(String typeName)
	{
//C# TO JAVA CONVERTER NOTE: The following 'switch' operated on a string member and was converted to Java 'if-else' logic:
//		switch (typeName.ToLower())
//ORIGINAL LINE: case "int":
		if (typeName.toLowerCase().equals("int"))
		{
				return Integer.class;
		}
//ORIGINAL LINE: case "bool":
		else if (typeName.toLowerCase().equals("bool"))
		{
				return Boolean.class;
		}
//ORIGINAL LINE: case "byte":
		else if (typeName.toLowerCase().equals("byte"))
		{
				return Byte.class;
		}
//ORIGINAL LINE: case "char":
		else if (typeName.toLowerCase().equals("char"))
		{
				return Character.class;
		}
//ORIGINAL LINE: case "decimal":
		else if (typeName.toLowerCase().equals("decimal"))
		{
				return java.math.BigDecimal.class;
		}
//ORIGINAL LINE: case "double":
		else if (typeName.toLowerCase().equals("double"))
		{
				return Double.class;
		}
//ORIGINAL LINE: case "float":
		else if (typeName.toLowerCase().equals("float"))
		{
				return Float.class;
		}
//ORIGINAL LINE: case "long":
		else if (typeName.toLowerCase().equals("long"))
		{
				return Long.class;
		}
//ORIGINAL LINE: case "object":
		else if (typeName.toLowerCase().equals("object"))
		{
				return Object.class;
		}
//ORIGINAL LINE: case "sbyte":
		else if (typeName.toLowerCase().equals("sbyte"))
		{
				return Byte.class;
		}
//ORIGINAL LINE: case "short":
		else if (typeName.toLowerCase().equals("short"))
		{
				return Short.class;
		}
//ORIGINAL LINE: case "string":
		else if (typeName.toLowerCase().equals("string"))
		{
				return String.class;
		}
//ORIGINAL LINE: case "uint":
		else if (typeName.toLowerCase().equals("uint"))
		{
				return Integer.class;
		}
//ORIGINAL LINE: case "ulong":
		else if (typeName.toLowerCase().equals("ulong"))
		{
				return Long.class;
		}
//ORIGINAL LINE: case "ushort":
		else if (typeName.toLowerCase().equals("ushort"))
		{
				return Short.class;
		}
		else
		{




				java.lang.Class rs = FindTypeInLoadedAssemblies(typeName);
				if (rs == null)
				{
					rs = FindTypeInLoadedAssemblies("System." + typeName);
				}
				if (rs != null)
				{
					return rs;
				}
				else
				{
					return java.lang.Class.forName(typeName, true, true);
				}

		}
	}

	private java.lang.Class FindTypeInLoadedAssemblies(String name)
	{
		for (Assembly asm : AppDomain.CurrentDomain.GetAssemblies())
		{
			java.lang.Class t = asm.GetType(name, false);
			if (t != null)
			{
				return t;
			}
		}

		return null;
	}
}