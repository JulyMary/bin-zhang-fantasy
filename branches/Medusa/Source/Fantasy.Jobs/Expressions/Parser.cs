// Generated by TinyPG v1.2 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace Fantasy.Jobs.Expressions
{
    #region Parser

    internal partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.NOT, TokenType.BROPEN, TokenType.NEGETIVE, TokenType.BOOL, TokenType.STRING, TokenType.INTEGER, TokenType.DECIMAL, TokenType.HEX, TokenType.IDENTITY); // Option Rule
            if (tok.Type == TokenType.NOT
                || tok.Type == TokenType.BROPEN
                || tok.Type == TokenType.NEGETIVE
                || tok.Type == TokenType.BOOL
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DECIMAL
                || tok.Type == TokenType.HEX
                || tok.Type == TokenType.IDENTITY)
            {
                ParseOrExpr(node); // NonTerminal Rule: OrExpr
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            if (tok.Type != TokenType.EOF)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseOrExpr(ParseNode parent) // NonTerminalSymbol: OrExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OrExpr), "OrExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseAndExpr(node); // NonTerminal Rule: AndExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.OR); // ZeroOrMore Rule
            while (tok.Type == TokenType.OR)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.OR); // Terminal Rule: OR
                if (tok.Type != TokenType.OR)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseAndExpr(node); // NonTerminal Rule: AndExpr
            tok = scanner.LookAhead(TokenType.OR); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: OrExpr

        private void ParseAndExpr(ParseNode parent) // NonTerminalSymbol: AndExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AndExpr), "AndExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseNotExpr(node); // NonTerminal Rule: NotExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
            while (tok.Type == TokenType.AND)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.AND); // Terminal Rule: AND
                if (tok.Type != TokenType.AND)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AND.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseNotExpr(node); // NonTerminal Rule: NotExpr
            tok = scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AndExpr

        private void ParseNotExpr(ParseNode parent) // NonTerminalSymbol: NotExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NotExpr), "NotExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.NOT); // Option Rule
            if (tok.Type == TokenType.NOT)
            {
                tok = scanner.Scan(TokenType.NOT); // Terminal Rule: NOT
                if (tok.Type != TokenType.NOT)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            }

             // Concat Rule
            ParseCompareExpr(node); // NonTerminal Rule: CompareExpr

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: NotExpr

        private void ParseCompareExpr(ParseNode parent) // NonTerminalSymbol: CompareExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CompareExpr), "CompareExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseAddExpr(node); // NonTerminal Rule: AddExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMPARER); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMPARER)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMPARER); // Terminal Rule: COMPARER
                if (tok.Type != TokenType.COMPARER)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPARER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseAddExpr(node); // NonTerminal Rule: AddExpr
            tok = scanner.LookAhead(TokenType.COMPARER); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CompareExpr

        private void ParseAddExpr(ParseNode parent) // NonTerminalSymbol: AddExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddExpr), "AddExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseMultExpr(node); // NonTerminal Rule: MultExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
            while (tok.Type == TokenType.PLUSMINUS)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.PLUSMINUS); // Terminal Rule: PLUSMINUS
                if (tok.Type != TokenType.PLUSMINUS)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseMultExpr(node); // NonTerminal Rule: MultExpr
            tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AddExpr

        private void ParseMultExpr(ParseNode parent) // NonTerminalSymbol: MultExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultExpr), "MultExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseCastExpr(node); // NonTerminal Rule: CastExpr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.MULTDIV); // ZeroOrMore Rule
            while (tok.Type == TokenType.MULTDIV)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.MULTDIV); // Terminal Rule: MULTDIV
                if (tok.Type != TokenType.MULTDIV)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTDIV.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                ParseCastExpr(node); // NonTerminal Rule: CastExpr
            tok = scanner.LookAhead(TokenType.MULTDIV); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: MultExpr

        private void ParseCastExpr(ParseNode parent) // NonTerminalSymbol: CastExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CastExpr), "CastExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.BROPEN); // ZeroOrMore Rule
            while (tok.Type == TokenType.BROPEN)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
                if (tok.Type != TokenType.BROPEN)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTITY); // Terminal Rule: IDENTITY
                if (tok.Type != TokenType.IDENTITY)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTITY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
                while (tok.Type == TokenType.DOT)
                {

                     // Concat Rule
                    tok = scanner.Scan(TokenType.DOT); // Terminal Rule: DOT
                    if (tok.Type != TokenType.DOT)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);

                     // Concat Rule
                    tok = scanner.Scan(TokenType.IDENTITY); // Terminal Rule: IDENTITY
                    if (tok.Type != TokenType.IDENTITY)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTITY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
                if (tok.Type != TokenType.BRCLOSE)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            tok = scanner.LookAhead(TokenType.BROPEN); // ZeroOrMore Rule
            }

             // Concat Rule
            ParseNegetiveExpr(node); // NonTerminal Rule: NegetiveExpr

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CastExpr

        private void ParseNegetiveExpr(ParseNode parent) // NonTerminalSymbol: NegetiveExpr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NegetiveExpr), "NegetiveExpr");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.NEGETIVE); // Option Rule
            if (tok.Type == TokenType.NEGETIVE)
            {
                tok = scanner.Scan(TokenType.NEGETIVE); // Terminal Rule: NEGETIVE
                if (tok.Type != TokenType.NEGETIVE)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NEGETIVE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            }

             // Concat Rule
            ParseAtom(node); // NonTerminal Rule: Atom

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: NegetiveExpr

        private void ParseAtom(ParseNode parent) // NonTerminalSymbol: Atom
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Atom), "Atom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.BOOL, TokenType.STRING, TokenType.INTEGER, TokenType.DECIMAL, TokenType.HEX, TokenType.IDENTITY, TokenType.BROPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BOOL:
                    tok = scanner.Scan(TokenType.BOOL); // Terminal Rule: BOOL
                    if (tok.Type != TokenType.BOOL)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                    if (tok.Type != TokenType.STRING)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.INTEGER:
                case TokenType.DECIMAL:
                case TokenType.HEX:
                    ParseNumber(node); // NonTerminal Rule: Number
                    break;
                case TokenType.IDENTITY:
                    ParseFunction(node); // NonTerminal Rule: Function
                    break;
                case TokenType.BROPEN:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
                    if (tok.Type != TokenType.BROPEN)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);

                     // Concat Rule
                    ParseOrExpr(node); // NonTerminal Rule: OrExpr

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
                    if (tok.Type != TokenType.BRCLOSE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Atom

        private void ParseNumber(ParseNode parent) // NonTerminalSymbol: Number
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Number), "Number");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DECIMAL, TokenType.HEX); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                    if (tok.Type != TokenType.INTEGER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.DECIMAL:
                    tok = scanner.Scan(TokenType.DECIMAL); // Terminal Rule: DECIMAL
                    if (tok.Type != TokenType.DECIMAL)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECIMAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.HEX:
                    tok = scanner.Scan(TokenType.HEX); // Terminal Rule: HEX
                    if (tok.Type != TokenType.HEX)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.HEX.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Number

        private void ParseFunction(ParseNode parent) // NonTerminalSymbol: Function
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Function), "Function");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTITY); // Terminal Rule: IDENTITY
            if (tok.Type != TokenType.IDENTITY)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTITY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

             // Concat Rule
            tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
            while (tok.Type == TokenType.DOT)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.DOT); // Terminal Rule: DOT
                if (tok.Type != TokenType.DOT)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTITY); // Terminal Rule: IDENTITY
                if (tok.Type != TokenType.IDENTITY)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTITY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            tok = scanner.LookAhead(TokenType.DOT); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BROPEN); // Terminal Rule: BROPEN
            if (tok.Type != TokenType.BROPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

             // Concat Rule
            ParseArguments(node); // NonTerminal Rule: Arguments

             // Concat Rule
            tok = scanner.Scan(TokenType.BRCLOSE); // Terminal Rule: BRCLOSE
            if (tok.Type != TokenType.BRCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Function

        private void ParseArguments(ParseNode parent) // NonTerminalSymbol: Arguments
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Arguments), "Arguments");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.NOT, TokenType.BROPEN, TokenType.NEGETIVE, TokenType.BOOL, TokenType.STRING, TokenType.INTEGER, TokenType.DECIMAL, TokenType.HEX, TokenType.IDENTITY); // Option Rule
            if (tok.Type == TokenType.NOT
                || tok.Type == TokenType.BROPEN
                || tok.Type == TokenType.NEGETIVE
                || tok.Type == TokenType.BOOL
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DECIMAL
                || tok.Type == TokenType.HEX
                || tok.Type == TokenType.IDENTITY)
            {

                 // Concat Rule
                ParseOrExpr(node); // NonTerminal Rule: OrExpr

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
                while (tok.Type == TokenType.COMMA)
                {

                     // Concat Rule
                    tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                    if (tok.Type != TokenType.COMMA)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);

                     // Concat Rule
                    ParseOrExpr(node); // NonTerminal Rule: OrExpr
                tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Arguments


    }

    #endregion Parser
}
