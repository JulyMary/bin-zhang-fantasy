package Fantasy.Jobs.Expressions;

// Generated by TinyPG v1.2 available at www.codeproject.com


public class Scanner
{
	public String Input;
	public int StartPos = 0;
	public int EndPos = 0;
	public int CurrentLine;
	public int CurrentColumn;
	public int CurrentPosition;
	public java.util.ArrayList<Token> Skipped; // tokens that were skipped
	public java.util.HashMap<TokenType, Regex> Patterns;

	private Token LookAheadToken;
	private java.util.ArrayList<TokenType> Tokens;
	private java.util.ArrayList<TokenType> SkipList; // tokens to be skipped

	public Scanner()
	{
		Regex regex;
		Patterns = new java.util.HashMap<TokenType, Regex>();
		Tokens = new java.util.ArrayList<TokenType>();
		LookAheadToken = null;

		SkipList = new java.util.ArrayList<TokenType>();
		SkipList.add(TokenType.WHITESPACE);

		regex = new Regex("^\\s*$", RegexOptions.Compiled);
		Patterns.put(TokenType.EOF, regex);
		Tokens.add(TokenType.EOF);

		regex = new Regex("@?'(\\\\'|[^'])*\\'", RegexOptions.Compiled);
		Patterns.put(TokenType.STRING, regex);
		Tokens.add(TokenType.STRING);

		regex = new Regex("\\d+", RegexOptions.Compiled);
		Patterns.put(TokenType.INTEGER, regex);
		Tokens.add(TokenType.INTEGER);

		regex = new Regex("\\d+((f|F)|\\.\\d+(f|F)?)", RegexOptions.Compiled);
		Patterns.put(TokenType.DECIMAL, regex);
		Tokens.add(TokenType.DECIMAL);

		regex = new Regex("0x((?i)[a-f\\d]\\+)", RegexOptions.Compiled);
		Patterns.put(TokenType.HEX, regex);
		Tokens.add(TokenType.HEX);

		regex = new Regex("\\+|\\-", RegexOptions.Compiled);
		Patterns.put(TokenType.PLUSMINUS, regex);
		Tokens.add(TokenType.PLUSMINUS);

		regex = new Regex("\\-", RegexOptions.Compiled);
		Patterns.put(TokenType.NEGETIVE, regex);
		Tokens.add(TokenType.NEGETIVE);

		regex = new Regex("\\*|\\\\|%|/", RegexOptions.Compiled);
		Patterns.put(TokenType.MULTDIV, regex);
		Tokens.add(TokenType.MULTDIV);

		regex = new Regex("\\(", RegexOptions.Compiled);
		Patterns.put(TokenType.BROPEN, regex);
		Tokens.add(TokenType.BROPEN);

		regex = new Regex("\\)", RegexOptions.Compiled);
		Patterns.put(TokenType.BRCLOSE, regex);
		Tokens.add(TokenType.BRCLOSE);

		regex = new Regex("(?i)(?!(and|or|not|true|false)(\\W|$))\\w+", RegexOptions.Compiled);
		Patterns.put(TokenType.IDENTITY, regex);
		Tokens.add(TokenType.IDENTITY);

		regex = new Regex("(?i)and", RegexOptions.Compiled);
		Patterns.put(TokenType.AND, regex);
		Tokens.add(TokenType.AND);

		regex = new Regex("(?i)or", RegexOptions.Compiled);
		Patterns.put(TokenType.OR, regex);
		Tokens.add(TokenType.OR);

		regex = new Regex("(?i)not", RegexOptions.Compiled);
		Patterns.put(TokenType.NOT, regex);
		Tokens.add(TokenType.NOT);

		regex = new Regex(">=|>|<=|<|==|!=", RegexOptions.Compiled);
		Patterns.put(TokenType.COMPARER, regex);
		Tokens.add(TokenType.COMPARER);

		regex = new Regex(",", RegexOptions.Compiled);
		Patterns.put(TokenType.COMMA, regex);
		Tokens.add(TokenType.COMMA);

		regex = new Regex("\\.|\\+", RegexOptions.Compiled);
		Patterns.put(TokenType.DOT, regex);
		Tokens.add(TokenType.DOT);

		regex = new Regex("(?i)true|false", RegexOptions.Compiled);
		Patterns.put(TokenType.BOOL, regex);
		Tokens.add(TokenType.BOOL);

		regex = new Regex("\\s+", RegexOptions.Compiled);
		Patterns.put(TokenType.WHITESPACE, regex);
		Tokens.add(TokenType.WHITESPACE);


	}

	public final void Init(String input)
	{
		this.Input = input;
		StartPos = 0;
		EndPos = 0;
		CurrentLine = 0;
		CurrentColumn = 0;
		CurrentPosition = 0;
		Skipped = new java.util.ArrayList<Token>();
		LookAheadToken = null;
	}

	public final Token GetToken(TokenType type)
	{
		Token t = new Token(this.StartPos, this.EndPos);
		t.Type = type;
		return t;
	}

	 /** 
	 executes a lookahead of the next token
	 and will advance the scan on the input string
	 
	 @return 
	 */
	public final Token Scan(TokenType... expectedtokens)
	{
		Token tok = LookAhead(expectedtokens); // temporarely retrieve the lookahead
		LookAheadToken = null; // reset lookahead token, so scanning will continue
		StartPos = tok.getEndPos();
		EndPos = tok.getEndPos(); // set the tokenizer to the new scan position
		return tok;
	}

	/** 
	 returns token with longest best match
	 
	 @return 
	*/
	public final Token LookAhead(TokenType... expectedtokens)
	{
		int i;
		int startpos = StartPos;
		Token tok = null;
		java.util.ArrayList<TokenType> scantokens;


		// this prevents double scanning and matching
		// increased performance
		if (LookAheadToken != null && LookAheadToken.Type != TokenType._UNDETERMINED_ && LookAheadToken.Type != TokenType._NONE_)
		{
			return LookAheadToken;
		}

		// if no scantokens specified, then scan for all of them (= backward compatible)
		if (expectedtokens.length == 0)
		{
			scantokens = Tokens;
		}
		else
		{
			scantokens = new java.util.ArrayList<TokenType>(expectedtokens);
			scantokens.addAll(SkipList);
		}

		do
		{

			int len = -1;
			TokenType index = (TokenType)Integer.MAX_VALUE;
			String input = Input.substring(startpos);

			tok = new Token(startpos, EndPos);

			for (i = 0; i < scantokens.size(); i++)
			{
				Regex r = Patterns.get(scantokens.get(i));
				Match m = r.Match(input);
				if (m.Success && m.Index == 0 && ((m.getLength() > len) || (scantokens.get(i) < index && m.getLength() == len)))
				{
					len = m.getLength();
					index = scantokens.get(i);
				}
			}

			if (index >= 0 && len >= 0)
			{
				tok.setEndPos(startpos + len);
				tok.setText(Input.substring(tok.getStartPos(), tok.getStartPos() + len));
				tok.Type = index;
			}
			else
			{
				if (tok.getStartPos() < tok.getEndPos() - 1)
				{
					tok.setText(Input.substring(tok.getStartPos(), tok.getStartPos() + 1));
				}
			}

			if (SkipList.contains(tok.Type))
			{
				startpos = tok.getEndPos();
				Skipped.add(tok);
			}
		}
		while (SkipList.contains(tok.Type));

		LookAheadToken = tok;
		return tok;
	}
}