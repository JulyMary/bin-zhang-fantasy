package fantasy.jobs.expressions;

import java.util.Arrays;
import java.util.List;
import java.util.regex.*;

import org.apache.commons.collections.ComparatorUtils;
import org.apache.commons.lang3.StringUtils;

import fantasy.jobs.properties.*;
import fantasy.*;
// Generated by TinyPG v1.2 available at www.codeproject.com



@SuppressWarnings("rawtypes")
public class ParseNode
{
	protected String text;
	protected java.util.ArrayList<ParseNode> nodes;

	public final java.util.ArrayList<ParseNode> getNodes()
	{
		return nodes;
	}

	public ParseNode Parent;
	public Token Token; // the token/rule
	public final String getText()
	{
		return text;
	}
	public final void setText(String value)
	{
		text = value;
	}

	public ParseNode CreateNode(Token token, String text)
	{
		ParseNode node = new ParseNode(token, text);
		node.Parent = this;
		return node;
	}

	protected ParseNode(Token token, String text)
	{
		this.Token = token;
		this.text = text;
		this.nodes = new java.util.ArrayList<ParseNode>();
	}

	protected final Object GetValue(ParseTree tree, TokenType type, int index) throws Exception
	{
		RefObject<Integer> tempRef_index = new RefObject<Integer>(index);
		Object tempVar = GetValue(tree, type, tempRef_index);
		index = tempRef_index.argvalue;
		return tempVar;
	}

	protected final Object GetValue(ParseTree tree, TokenType type, RefObject<Integer> index) throws Exception
	{
		Object o = null;
		if (index.argvalue < 0)
		{
			return o;
		}

		// left to right
		for (ParseNode node : nodes)
		{
			if (node.Token.Type == type)
			{
				index.argvalue--;
				if (index.argvalue < 0)
				{
					o = node.Eval(tree);
					break;
				}
			}
		}
		return o;
	}

	/** 
	 this implements the evaluation functionality, cannot be used directly
	 
	 @param tree the parsetree itself
	 @param paramlist optional input parameters
	 @return a partial result of the evaluation
	 * @throws Exception 
	*/
	public final Object Eval(ParseTree tree, Object... paramlist) throws Exception
	{
		Object Value = null;

		switch (Token.Type)
		{
			case Start:
				Value = EvalStart(tree, paramlist);
				break;
			case OrExpr:
				Value = EvalOrExpr(tree, paramlist);
				break;
			case AndExpr:
				Value = EvalAndExpr(tree, paramlist);
				break;
			case NotExpr:
				Value = EvalNotExpr(tree, paramlist);
				break;
			case CompareExpr:
				Value = EvalCompareExpr(tree, paramlist);
				break;
			case AddExpr:
				Value = EvalAddExpr(tree, paramlist);
				break;
			case MultExpr:
				Value = EvalMultExpr(tree, paramlist);
				break;
			case CastExpr:
				Value = EvalCastExpr(tree, paramlist);
				break;
			case NegetiveExpr:
				Value = EvalNegetiveExpr(tree, paramlist);
				break;
			case Atom:
				Value = EvalAtom(tree, paramlist);
				break;
			case Number:
				Value = EvalNumber(tree, paramlist);
				break;
			case Function:
				Value = EvalFunction(tree, paramlist);
				break;
			case Arguments:
				Value = EvalArguments(tree, paramlist);
				break;
			case STRING:
				Value = EvalSTRING(tree, paramlist);
				break;
			case INTEGER:
				Value = EvalINTEGER(tree, paramlist);
				break;
			case HEX:
				Value = EvalHex(tree, paramlist);
				break;
			case DECIMAL:
				Value = EvalDECIMAL(tree, paramlist);
				break;
			case BOOL :
				Value = EvalBOOL(tree, paramlist);
				break;
			default:
				Value = Token.getText();
				break;
		}
		return Value;
	}






	private int GetTokenCount(TokenType tokenType)
	{

		int rs = 0;
		for(ParseNode n : this.getNodes())
		{
			if (n.Token.Type == tokenType)
			{
				rs ++;
			}
		}
		
		return rs;
		
		
	}


	private Object EvalDECIMAL(ParseTree tree, Object[] paramlist)
	{
		
		String s = StringUtils2.trimEnd(this.Token.getText(), 'f', 'F');
		return Float.parseFloat(s);
	}

	private Object EvalHex(ParseTree tree, Object[] paramlist)
	{
		String s = this.Token.getText().substring(2);
		return Integer.parseInt(s, 16);

	}

	private Object EvalINTEGER(ParseTree tree, Object[] paramlist)
	{
		return Integer.parseInt(this.Token.getText());
	}

	private Object EvalSTRING(ParseTree tree, Object[] paramlist)
	{
		Pattern reg = Pattern.compile("\\\\(0x(?<hex4>[0-9a-fA-F]{4})|0x(?<hex2>[0-9a-fA-F]{2})|(?<oct>[0-7]{3})|(?<char>.?))");

		String text = this.Token.getText();
		if (text.startsWith("@"))
		{
			char quotation = text.charAt(1);
			String rs = text.substring(2, 2 + text.length() - 3).replace( StringUtils.repeat(quotation, 2), (new Character(quotation)).toString());
			return rs;
		}
		else
		{
			text = text.substring(1, 1 + text.length() - 2);
			StringBuilder rs = new StringBuilder();
			int s = 0;
			while (s < text.length())
			{
				Matcher m = reg.matcher(text.substring(s));
				if (m.lookingAt())
				{
					rs.append(text.substring(s, m.start()));

					char value;
					if (m.group("hex4") != null)
					{
						value = (char)(Integer.parseInt(m.group("hex4"), 16));
					}
					else if (m.group("hex2")!= null)
					{
						value = (char)(Integer.parseInt(m.group("hex2"), 16));
					}
					else if (m.group("oct") != null)
					{
						value = (char)(Integer.parseInt(m.group("oct"), 8));
					}
					else
					{
						if (m.group("char").equals("a"))
						{
								value = (char)0x07;

						}
						else if (m.group("char").equals("b"))
						{
								value = '\b';
						}
						else if (m.group("char").equals("f"))
						{
								value = '\f';
						}
						else if (m.group("char").equals("n"))
						{
								value = '\n';
						}
						else if (m.group("char").equals("r"))
						{
								value = '\r';
						}
						else if (m.group("char").equals("t"))
						{
								value = '\t';
						}
						else if (m.group("char").equals("v"))
						{
								value = '\u000b';
						}
						else if (m.group("char").equals("'"))
						{
								value = '\'';
						}
						else if (m.group("char").equals("\\"))
						{
								value = '\\';
						}
						else
						{
								throw new IllegalStateException(String.format("Unrecognized escape sequences in string '%1$s'.", text));

						}
					}
					rs.append(value);
					s = m.end();
				}
				else
				{
					rs.append(text.substring(s));
					s = text.length();
				}
			}

			return rs.toString();
		}



	}

	protected Object EvalStart(ParseTree tree, Object... paramlist) throws Exception
	{
		if (this.GetTokenCount(TokenType.OrExpr) == 1)
		{
			return this.GetValue(tree, TokenType.OrExpr, 0);
		}
		else
		{
			return null;
		}

	}

	protected Object EvalOrExpr(ParseTree tree, Object... paramlist) throws Exception
	{
		int count = this.GetTokenCount(TokenType.AndExpr);
		if (count == 1)
		{
			return this.GetValue(tree, TokenType.AndExpr, 0);
		}
		else
		{
			for (int i = 0; i < count; i++)
			{
				if ((boolean)this.GetValue(tree, TokenType.AndExpr, i))
				{
					return true;
				}
			}
			return false;
		}
	}

	protected Object EvalAndExpr(ParseTree tree, Object... paramlist) throws Exception
	{
		int count = this.GetTokenCount(TokenType.NotExpr);
		if (count == 1)
		{
			return this.GetValue(tree, TokenType.NotExpr, 0);
		}
		else
		{
			for (int i = 0; i < count; i++)
			{
				if (!(boolean)this.GetValue(tree, TokenType.NotExpr, i))
				{
					return false;
				}
			}
			return true;
		}
	}

	protected Object EvalNotExpr(ParseTree tree, Object... paramlist) throws Exception
	{
		Object value = this.GetValue(tree, TokenType.CompareExpr, 0);
		if (this.GetTokenCount(TokenType.NOT) == 1)
		{
			return !((Boolean)value).booleanValue();
		}
		else
		{
			return value;
		}
	}

	protected Object EvalCompareExpr(ParseTree tree, Object... paramlist) throws Exception
	{
		int count = this.GetTokenCount(TokenType.AddExpr);

		Object rs = this.GetValue(tree, TokenType.AddExpr, 0);
		for (int i = 1; i < count; i++)
		{
			Object val = this.GetValue(tree, TokenType.AddExpr, 1);
			@SuppressWarnings("unchecked")
			int cmp = ComparatorUtils.naturalComparator().compare(rs, val);

			if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1) ==">=" )
			{
					rs = cmp >= 0;
			}

			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1) == (">"))
			{
					rs = cmp > 0;
			}
			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1) ==("<="))
			{
					rs = cmp <= 0;
			}
			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1)==("<"))
			{
					rs = cmp < 0;
			}
			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1)==("=="))
			{
					rs = cmp == 0;
			}
			else if ((String)this.GetValue(tree, TokenType.COMPARER, i - 1)==("!="))
			{
					rs = cmp != 0;
			}
			else
			{
					throw new RuntimeException("Absurd");
			}
		}
		return rs;

	}

	
	private static List<Class> _intTypes = Arrays.asList(new Class[] {byte.class, Byte.class, short.class, Short.class, int.class, Integer.class, long.class, Long.class}); 
	private static List<Class> _decTypes = Arrays.asList(new Class[] {float.class, Float.class, double.class, Double.class}); 
	private static List<Class> _strTypes = Arrays.asList(new Class[] {String.class, char.class, Character.class});
	private String EvalType(Object value)
	{
       
		Class type = value.getClass();
        if(_intTypes.indexOf(type) >= 0)
        {
        	return "int";
        }
        else if(_decTypes.indexOf(type) >= 0)
        {
        	return "dec";
        }
        else if(_strTypes.indexOf(type) >= 0)
        {
        	return "str";
        }
        else
        {
        	return "un";
        }
		
	}

	protected Object EvalAddExpr(ParseTree tree, Object... paramlist) throws Exception
	{
		int count = this.GetTokenCount(TokenType.MultExpr);
		if (count > 1)
		{

			Object rs = null;
			String oldType = "un";
			for (int i = 0; i < count; i++)
			{
				Object o = this.GetValue(tree, TokenType.MultExpr, i);
				if (i == 0)
				{
					rs = o;
					oldType = EvalType(rs);
				}
				else
				{

					String newType = EvalType(o);
					int op = (String)this.GetValue(tree, TokenType.PLUSMINUS, i - 1) == ("+") ? 1 : -1;

					if (oldType == "int" && newType =="int" )
					{
						rs = ((Integer)rs).intValue() + op * ((Integer)o).intValue();
					}
					else if (oldType == "int"  && newType == "dec")
					{
						rs = (double)rs + op * (double)o;
						oldType = "dec";
					}
					else if (oldType == "dec" && (newType =="dec" || newType =="int"))
					{
						rs = (double)rs + op * (double)o;
					}
					else if (oldType == "str" && newType =="str")
					{
						if (op == 1)
						{
							rs = (String)rs + (String)o;
						}
						else
						{
							throw new IllegalStateException(Resources.getDoNotSupportMinusStringText());
						}
					}
					else
					{
						throw new IllegalStateException(String.format(Resources.getDoNotSupportPlusText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
					}

				}
			}

			return rs;
		}
		else
		{
			return this.GetValue(tree, TokenType.MultExpr, 0);
		}

	}

	protected Object EvalMultExpr(ParseTree tree, Object... paramlist) throws Exception
	{
		int count = this.GetTokenCount(TokenType.CastExpr);
		if (count > 1)
		{
			Object rs = null;
			String oldType = "un";
			for (int i = 0; i < count; i++)
			{
				Object o = this.GetValue(tree, TokenType.CastExpr, i);
				if (i == 0)
				{
					rs = o;
					oldType = EvalType(rs);
				}
				else
				{

					String newType = EvalType(o);
					String op = (String)this.GetValue(tree, TokenType.MULTDIV, i - 1);


					if (op.equals("\\"))
					{
							if (oldType.equals("int") && newType.equals("int"))
							{
								rs = ((Integer)rs).intValue() / ((Integer)o).intValue();
							}
							else
							{
								throw new IllegalStateException(String.format(Resources.getDoNotSupportDivideExactlyText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
							}
					}
//ORIGINAL LINE: case "%":
					else if (op.equals("%"))
					{
							if (oldType.equals("int") && newType.equals("int"))
							{
								rs = ((Integer)rs).intValue() % ((Integer)o).intValue();
							}
							else
							{
								throw new IllegalStateException(String.format(Resources.getDoNotSupportModulusText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
							}
					}
//ORIGINAL LINE: case "/":
					else if (op.equals("/"))
					{
							if (oldType.equals("int") && newType.equals("int"))
							{
								rs = ((Integer)rs).intValue() / ((Integer)o).intValue();
							}
							else if ((oldType.equals("int") || oldType.equals("dec")) && (newType.equals("int") || newType.equals("dec")))
							{
								rs = (double)rs / (double)o;
								oldType = "dec";
							}
							else
							{
								throw new IllegalStateException(String.format(Resources.getDoNotSupportMultDivText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
							}
					}
//ORIGINAL LINE: case "*":
					else if (op.equals("*"))
					{
							if (oldType.equals("int") && newType.equals("int"))
							{
								rs = ((Integer)rs).intValue() * ((Integer)o).intValue();
							}
							else if ((oldType.equals("int") || oldType.equals("dec")) && (newType.equals("int") || newType.equals("dec")))
							{
								rs = (double)rs * (double)o;
								oldType = "dec";
							}
							else
							{
								throw new IllegalStateException(String.format(Resources.getDoNotSupportMultDivText(), (rs != null) ? rs : "null", (o != null) ? o : "null"));
							}
					}

				}
			}

			return rs;
		}
		else
		{
			return this.GetValue(tree, TokenType.CastExpr, 0);
		}
	}

	protected Object EvalNegetiveExpr(ParseTree tree, Object... paramlist) throws Exception
	{
		Object rs = this.GetValue(tree, TokenType.Atom, 0);
		if ((String)this.GetValue(tree, TokenType.NEGETIVE, 0) == ("-"))
		{
			String type = this.EvalType(rs);

			if (type.equals("int"))
			{
					return -((Integer)rs).intValue();
			}
			else if (type.equals("dec"))
			{
					return -(double)rs;
			}
			else
			{
					throw new IllegalStateException(String.format(Resources.getDoNotSupportNagetiveText(), (rs != null) ? rs : "null"));
			}
		}
		else
		{
			return rs;
		}
	}

	protected Object EvalAtom(ParseTree tree, Object... paramlist) throws Exception
	{
		if (this.GetTokenCount(TokenType.STRING) == 1)
		{
			return this.GetValue(tree, TokenType.STRING, 0);
		}
		else if (this.GetTokenCount(TokenType.Number) == 1)
		{
			return this.GetValue(tree, TokenType.Number, 0);
		}
		else if (this.GetTokenCount(TokenType.Function) == 1)
		{
			return this.GetValue(tree, TokenType.Function, 0);
		}
		else if (this.GetTokenCount(TokenType.BOOL) == 1)
		{
			return this.GetValue(tree, TokenType.BOOL, 0);
		}
		else
		{
			return this.GetValue(tree, TokenType.OrExpr, 0);
		}
	}

	protected Object EvalNumber(ParseTree tree, Object... paramlist) throws Exception
	{
		if (this.GetTokenCount(TokenType.INTEGER) == 1)
		{
			return this.GetValue(tree, TokenType.INTEGER, 0);
		}
		if (this.GetTokenCount(TokenType.DECIMAL) == 1)
		{
			return this.GetValue(tree, TokenType.DECIMAL, 0);
		}
		else
		{
			return this.GetValue(tree, TokenType.HEX, 0);
		}
	}

	protected Object EvalFunction(ParseTree tree, Object... paramlist) throws Exception
	{
		int count = this.GetTokenCount(TokenType.IDENTITY);

		String method = (String)this.GetValue(tree, TokenType.IDENTITY, count - 1);

		StringBuilder typeName = new StringBuilder();
		for (int i = 0; i < count - 1; i++)
		{
			if (i > 0)
			{
				typeName.append(this.GetValue(tree, TokenType.DOT, i));
			}
			typeName.append(this.GetValue(tree, TokenType.IDENTITY, i));

		}


		java.lang.Class t = this.ResolveType(typeName.toString());
		Object[] args = (Object[])this.GetValue(tree, TokenType.Arguments, 0);
		return tree.OnInvokeFunction(t, method, args);

	}

	protected Object EvalArguments(ParseTree tree, Object... paramlist) throws Exception
	{
		int count = this.GetTokenCount(TokenType.OrExpr);
		Object[] rs = new Object[count];
		for (int i = 0; i < count; i++)
		{
			rs[i] = this.GetValue(tree, TokenType.OrExpr, i);
		}

		return rs;
	}

	protected Object EvalCastExpr(ParseTree tree, Object... paramlist) throws Exception
	{
		Object value = this.GetValue(tree, TokenType.NegetiveExpr, 0);
		int count = this.GetTokenCount(TokenType.IDENTITY);
		if (count > 0)
		{
			StringBuilder typeName = new StringBuilder();
			for (int i = 0; i < count; i++)
			{
				typeName.append(this.GetValue(tree, TokenType.IDENTITY, i));
				if (i > 0)
				{
					typeName.append(this.GetValue(tree, TokenType.DOT, i-1));
				}
			}

			java.lang.Class t = ResolveType(typeName.toString());

			value = t.cast(value);
			
		}

		return value;

	}

	private Object EvalBOOL(ParseTree tree, Object[] paramlist)
	{
		return Boolean.parseBoolean(this.Token.getText());
	}

	protected final java.lang.Class ResolveType(String typeName) throws Exception
	{

		if (typeName.toLowerCase().equals("int"))
		{
				return int.class;
		}

		else if (typeName.toLowerCase().equals("bool"))
		{
				return boolean.class;
		}

		else if (typeName.toLowerCase().equals("byte"))
		{
				return byte.class;
		}
		else if (typeName.toLowerCase().equals("char"))
		{
				return char.class;
		}
		else if (typeName.toLowerCase().equals("double"))
		{
				return double.class;
		}

		else if (typeName.toLowerCase().equals("float"))
		{
				return float.class;
		}

		else if (typeName.toLowerCase().equals("long"))
		{
				return long.class;
		}
		else if (typeName.toLowerCase().equals("short"))
		{
				return short.class;
		}

		else
		{
			return java.lang.Class.forName(typeName);

				
		}
	}

	
}